To do this, I have another register “saved_first” which holds the current value found in ITEM_CODE as the first digit. If we look at the diagram of the possible input codes, we see the first digit can only be 0 or 1. So if the value within ITEM_CODE is greater than 1 when KEY_PRESS is high, I will set the output INVALID_SEL to high, and transfer to the IDLE state. Another case that will cause this INVALID_SEL output to be set to high is if KEY_PRESS is not set to high within five clock cycles of CARD_IN being set to high. To count these five clock cycles, I created a counter that counts up on every posedge of the clk. Within the states that need to switch by 5 clock cycles, before I enter that state, I make sure to reset the counter, and then I add an extra check that checks if the counter has reached 0’b0100; if so, I set “next_state” to the appropriate value. If KEY_PRESS is high and ITEM_CODE is 0 or 1 within 5 clock cycles, then I set “next_state” to WAITSELTWO. In WAITSELTWO, the machine waits for the second digit to be inputted. From here it can also be invalid if the KEY_PRESS input is not high within five clock cycles, or if KEY_PRESS is high and the value in ITEM_CODE is greater than 9; since the largest valid second digit is 9. Like before, I add an extra check to see if the counter has counted up to 4’b0100. For this invalid state, I will set INVALID_SEL to 1 and have next_state be IDLE. However, if the second digit input is valid, I will store the value in ITEM_CODE to a register “saved_two”, and then the next_state will be CHKAMT. During CHKAMT, the machine checks the inventory count of the requested item, which is found through the values in “saved_first” and “saved_second”. To do this I hardcoded if statements that would check the correct register based off the two digits I stored. If the value found is greater than 0, then we know we will be able to vend it, and will move to the next state, WAITTRAN. However, if the value is 0, we cannot vend it so we set INVALID_SEL to 1 and make “next_state” IDLE. In WAITTRAN, we wait for the input VALID_TRAN to be high, because that signifies that the transaction went through. Again, we must make sure it occurs within 5 clock cycles, so before I enter this state I make sure the counter is reset, and then I have a check within the state that will set FAILED_TRAN to 1 if the counter has counted up to 4’b0100, and the input VALID_TRAN is still low. If VALID_TRAN is 1 within 5 clock cycles, we can display the cost and set the “next_state” to VENDACT, which is actually vending the item. Again, to display the cost, I hardcoded if statements that utilize the “saved_first” and “saved_second” registers to set the value COST to the correct corresponding cost value for the item. Now that we have reached VENDACT, we can proceed with the actual vending of the requested item. This is done by decrementing the inventory value for the requested item by 1. To do this, above in CHKAMT I actually saved the value of the inventory decremented by 1 in a register “next_stock”. So in VENDACT, I simply assign the value in “next_stock” to the requested item’s inventory count, which effectively decrements it. To signal that this action has been taken, the machine then sets the output VEND to 1. The next state requires the customer to open the door and pick up the item, so we proceed to state WAITDOORHIGH. In WAITDOORHIGH, the machine must wait for the input DOOR_OPEN to be set to high within 5 clock cycles. Like before, I make sure the counter I use is reset, and within the state I check if the counter has counted 5 clock cycles and DOOR_OPEN is still low. If this is the case, I assign next_state to be IDLE. Otherwise, if the door has been opened successfully, we can move on to the next state, WAITDOORLOW. Now we must wait for the customer to close the vending machine door, so we wait for the DOOR_OPEN signal to go low. This doesn’t have a time limit, so we could be stuck here forever if the signal never goes low. But once it does, we go back to the IDLE state. To better visualize what I have just explained, the finite state machine is included in below, Figure 1. It shows how each state reacts to different inputs and what states switch to given their outputs. The code above simply runs through a second transaction, this time with itemZero. We see at the end of the transaction, it appears to work correctly as COST is outputting 001, which is the cost of itemZero, the value in itemZero is 9, showing it has been correctly decremented, VEND is high, and the error signals, INVALID_SEL and FAILED_TRAN are both low. This is shown below in Figure 9. This lab was designed to teach us how to design our own FSM and use Verilog to implement it. It illustrated the importance of the concept of creating the interface before the implementation. By having to design the FSM first, we can ensure that our code will work correctly and according to the spec, and that all inputs are correctly addressed and handled. In the end, I was able to create a vending machine FSM, which took in inputs for a card, item code, reloading the machine, resetting the machine, and opening/closing the vending machine door. The success of the vending machine depended on handling timing correctly, and order of inputs and their values. The greatest challenge I had was figuring out what should be placed in which always loop, as one of my always loops was triggered by posedge clk. However, timing issues were easily solved through including intermediate values and waveforms in my test bench so when I ran the simulation I could see if things were being triggered correctly and accurately in my waveforms. To do this, I have another register “saved_first” which holds the current value found in ITEM_CODE as the first digit. If we look at the diagram of the possible input codes, we see the first digit can only be 0 or 1. So if the value within ITEM_CODE is greater than 1 when KEY_PRESS is high, I will set the output INVALID_SEL to high, and transfer to the IDLE state. Another case that will cause this INVALID_SEL output to be set to high is if KEY_PRESS is not set to high within five clock cycles of CARD_IN being set to high. To count these five clock cycles, I created a counter that counts up on every posedge of the clk. Within the states that need to switch by 5 clock cycles, before I enter that state, I make sure to reset the counter, and then I add an extra check that checks if the counter has reached 0’b0100; if so, I set “next_state” to the appropriate value. If KEY_PRESS is high and ITEM_CODE is 0 or 1 within 5 clock cycles, then I set “next_state” to WAITSELTWO. In WAITSELTWO, the machine waits for the second digit to be inputted. From here it can also be invalid if the KEY_PRESS input is not high within five clock cycles, or if KEY_PRESS is high and the value in ITEM_CODE is greater than 9; since the largest valid second digit is 9. Like before, I add an extra check to see if the counter has counted up to 4’b0100. For this invalid state, I will set INVALID_SEL to 1 and have next_state be IDLE. However, if the second digit input is valid, I will store the value in ITEM_CODE to a register “saved_two”, and then the next_state will be CHKAMT. During CHKAMT, the machine checks the inventory count of the requested item, which is found through the values in “saved_first” and “saved_second”. To do this I hardcoded if statements that would check the correct register based off the two digits I stored. If the value found is greater than 0, then we know we will be able to vend it, and will move to the next state, WAITTRAN. However, if the value is 0, we cannot vend it so we set INVALID_SEL to 1 and make “next_state” IDLE. In WAITTRAN, we wait for the input VALID_TRAN to be high, because that signifies that the transaction went through. Again, we must make sure it occurs within 5 clock cycles, so before I enter this state I make sure the counter is reset, and then I have a check within the state that will set FAILED_TRAN to 1 if the counter has counted up to 4’b0100, and the input VALID_TRAN is still low. If VALID_TRAN is 1 within 5 clock cycles, we can display the cost and set the “next_state” to VENDACT, which is actually vending the item. Again, to display the cost, I hardcoded if statements that utilize the “saved_first” and “saved_second” registers to set the value COST to the correct corresponding cost value for the item. Now that we have reached VENDACT, we can proceed with the actual vending of the requested item. This is done by decrementing the inventory value for the requested item by 1. To do this, above in CHKAMT I actually saved the value of the inventory decremented by 1 in a register “next_stock”. So in VENDACT, I simply assign the value in “next_stock” to the requested item’s inventory count, which effectively decrements it. To signal that this action has been taken, the machine then sets the output VEND to 1. The next state requires the customer to open the door and pick up the item, so we proceed to state WAITDOORHIGH. In WAITDOORHIGH, the machine must wait for the input DOOR_OPEN to be set to high within 5 clock cycles. Like before, I make sure the counter I use is reset, and within the state I check if the counter has counted 5 clock cycles and DOOR_OPEN is still low. If this is the case, I assign next_state to be IDLE. Otherwise, if the door has been opened successfully, we can move on to the next state, WAITDOORLOW. Now we must wait for the customer to close the vending machine door, so we wait for the DOOR_OPEN signal to go low. This doesn’t have a time limit, so we could be stuck here forever if the signal never goes low. But once it does, we go back to the IDLE state. To better visualize what I have just explained, the finite state machine is included in below, Figure 1. It shows how each state reacts to different inputs and what states switch to given their outputs. The code above simply runs through a second transaction, this time with itemZero. We see at the end of the transaction, it appears to work correctly as COST is outputting 001, which is the cost of itemZero, the value in itemZero is 9, showing it has been correctly decremented, VEND is high, and the error signals, INVALID_SEL and FAILED_TRAN are both low. This is shown below in Figure 9. This lab was designed to teach us how to design our own FSM and use Verilog to implement it. It illustrated the importance of the concept of creating the interface before the implementation. By having to design the FSM first, we can ensure that our code will work correctly and according to the spec, and that all inputs are correctly addressed and handled. In the end, I was able to create a vending machine FSM, which took in inputs for a card, item code, reloading the machine, resetting the machine, and opening/closing the vending machine door. The success of the vending machine depended on handling timing correctly, and order of inputs and their values. The greatest challenge I had was figuring out what should be placed in which always loop, as one of my always loops was triggered by posedge clk. However, timing issues were easily solved through including intermediate values and waveforms in my test bench so when I ran the simulation I could see if things were being triggered correctly and accurately in my waveforms.